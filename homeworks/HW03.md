## Amir ElTabakh - HW 3
### SQL â€“ Math 290
### 02/26/2022

1.	 
For our first exercise we had to populate four spreadsheets on google sheets to begin documenting our knowledge base. There are four spreadsheets total.
 - `creators`: the primary key is the id column and relation has first_name, last_name, creator_name, and operating_system attributes. It has one row for every person who would create content in the Google Sheet. It has no foreign keys.
 - `errors`: the primary key is the id column and the relation has reporter_id, reported_date, error_message, short_description, and link_to_error_write_up attributes. The relation has one tuple for every error a creator experienced.  Reporter_id is the foreign key referencing the id field in the `creators` table. 
 - `error_resolution`: the primary key is the id column and the relation has error_id, reporter_id, resolution_link attributes. The relation has one tuple for every resolution a creator has reported.  It has two foreign keys error_id and reporter_id. Error_id references the id field in the `errors` relation and reporter_id references the id field in the `creators` relation.
 - `learning_point`: the primary key is the id column and the relation has creator_id, concept_name, short_description, link_to_explanation_document attributes. The relation has one tuple for every learning point a creator posted. It has a foreign key creator_id referencing the id field in the `creators` relation.

For now we don't create a schema for these relations/data files. I populated my information on a single row on the `creators` spreadsheet. **ADD ERROR**

2.
The exercise was to complete the download and import of the 2018 yellow taxi dataset onto DBeaver. I completed this task last week.

3.

We write a SELECT statement against the taxi dataset (called taxi_data). The purpose of this is to confirm that the dataset is imported in its entirety.

`select count(*) as observation_count from taxi_data;`

![](https://github.com/sfnxboy/SQL_Math-290/blob/main/homeworks/images/hw03_01_select_taxi_data.png)

Referencing the approximate record found on [NYC Open Data page](https://data.cityofnewyork.us/Transportation/2018-Yellow-Taxi-Trip-Data/t29m-gskq), I can confirm that the dataset has been imported in its entirety.

4.
One aspect of a primary key is that it is unique. Let's check if the `vendor_id` could be a candidate to be a primary key by checking if it is unique.

![](https://github.com/sfnxboy/SQL_Math-290/blob/main/homeworks/images/hw03_02_distinct.png)

Based on these two numbers the `vendor_id` column is not a good candidate for the being a primary key. A primary key should be a column that consists of unique values, and this column only has 3 unique values. Below are a few properties of primary keys and unique keys.

**Primary Keys**
- There can only be one primary key per table.
- It does not allow for null values.
- The default index is clustered, that is the primary key is that sorts the rows by index in a specific order. When we create a table with a primary key constraint, a clustered index is automatically created by default based on this primary key.
- The purpose of the primary key is to enforce entity integrity. For instance, each table represents and entity, and each row of a table represents an instance of that entity. To identify each row in a table, the table must have a primary key. The primary key is a unique value that identifies each row. This requirement is called the entity idtegrity constraint.
- Duplicate keys are not allowed.

**Unique Keys**
- There can be multiple unique keys per table.
- Allows for null values.
- Default index is not clustered.
- The purpose of the key is to enforce unique data.
- If one or more key parts are null, then duplicate keys are allowed.


